# About
In my [mobilenotifier](https://github.com/rmsk2/mobilenotifier) project I need functionality to send SMS (text) messages to
the recipients of notifications. In a first implementation I used IFTTT to achieve this goal. IFTTT allows to define a webhook
which, if called, causes an Android mobile phone, on which the IFTTT app is installed, to send a text message to predefined receivers.
Apart from working around power management functions on the phone in order to force the immediate sending of the text message this
worked satisfactorily, but is rather convoluted. In the end a more direct approach was more appealing to me.

I bought a GSM modem based on the Wavecom Q2303A chipset which connects via USB to a machine and allows to send SMS messages via
old fashioned AT commands. This software, if run on a machine to which such a modem is connected, provides a REST service which
allows to send SMS messages to arbitrary recipients.

# Building and installing
The software depends on [go.bug.st/serial](https://github.com/bugst/go-serial), a library which allows go code to talk to RS-232
serial devices. After installing `go-serial` the service can be built by executing `go build`. A primitive script (`build_raspi.sh`) 
which performs cross compilation to a (64 bit) ARMv8  Linux target (i.e. a Raspberry Pi 3 or later) is also provided. Authentication
is based on an HMACed or ECDSA signed JWT. The JWT could be issued by [tokenissuer](https://github.com/rmsk2/tokenissuer) or via
`smssender` itself. At the moment all valid tokens are accepted independent of their issuing date. When started the following environment
variables can be set in order to configure the behaviour of `smssender`.

| Variable | Value |
|-|-|
|`GSM_MODEM_FILE_ROOT`| Name of a file in which the root certificate for the server cert is stored. Default value: `private-tls-ca.pem`. |
|`GSM_MODEM_ALLOWED_AUDIENCE`| The expected `aud` value in the JWT. Default value: `local_sms_sender`|
|`GSM_MODEM_TOKEN_TYPE`| If set to `ES256`, `ES384`, `HS256` or `HS384` then `smssender` will make us of the corresponding algorithm to sign and verify JWTs. This value controls how `GSM_MODEM_VERIFICATION_SECRET` and `GSM_MODEM_SIGNING_SECRET` are interpreted.  If the variable is not set or set to a value not listed above the algorithm `HS256` is used |
|`GSM_MODEM_VERIFICATION_SECRET`| The HMAC secret or ECDSA public key which is used to verify JWTs. Default value: `a-string-secret-at-least-256-bits-long`. This value is required. If an HMAC signature algorithm is used (i.e. `HS256` or `HS384`) this value is also copied to `GSM_MODEM_SIGNING_SECRET` |
|`GSM_MODEM_SIGNING_SECRET`| The HMAC secret or ECDSA private key which is used to sign JWTs. Default value: `a-string-secret-at-least-256-bits-long`. If an HMAC signature algorithm is used this value is ignored. If an ECDSA signature algorithm (i.e. `ES256` or `ES384`) is used this value is optional. If it is not provided signing a token via the `-t` option is not possible |
|`GSM_MODEM_FILE_CERT`| File which holds the TLS server cert used by `smssender`. Default value: `server.crt`|
|`GSM_MODEM_FILE_KEY`| File which holds the TLS server cert private key used by `smssender`. Default value: `server.pem`|
|`GSM_MODEM_NAME_ISSUER`| The expected `iss` value in the JWT. Default value: `daheim_token_issuer`|
|`GSM_MODEM_SIM_PIN`| The PIN of the SIM card in the modem. Default value: `0000`|
|`GSM_MODEM_SERIAL_PORT`| The serial device to to be used. Default value: `/dev/ttyUSB0`|
|`GSM_MODEM_LISTENER_PORT`| The TCP port on which the service should listen. Default value: 4443|
|`GSM_MODEM_DUMMY`| If set to any value, a dummy modem is used instead of a real GSM modem. The dummy modem prints the phone number and message to stdout instead of sending an SMS. Useful for development and testing without physical hardware.|

As the software needs to be executed on a machine to which a modem is connected it is a bit difficult to run it in a kubernetes cluster.
When started with the option `-t` a JWT is created and then `smssender` exits. This can be used to for instance generate a token for `mobilenotifier`.
The parameter of the `-t` option is included in the generated token as the `sub` (subject) field. Here an example of such a call: 
`gsmmodem -t test_client`.

You must at least set `GSM_MODEM_SIM_PIN` and if you don't change the default value for `GSM_MODEM_VERIFICATION_SECRET`, your HMACEed JWTs can be 
easily forged. You can issue your own TLS certificates using your own CA via [minica](https://github.com/rmsk2/minica).

# Running the service (during development)

I use the following script to configure and start the service together with a token generated by `smssender` itself. For the rest of the
environment variables I use the default values.

```
export GSM_MODEM_SIM_PIN=XXXXXX
export GSM_MODEM_NAME_ISSUER=gsm_modem
export GSM_MODEM_ALLOWED_AUDIENCE=gsm_modem
export GSM_MODEM_VERIFICATION_SECRET=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
./gsmmodem

```

This will create an HMAC-SHA256 based JWT. If you prefer ECDSA based JWTs you have to set `GSM_MODEM_VERIFICATION_SECRET` to the public key and `GSM_MODEM_SIGNING_SECRET`
to the corresponding private key. This can be achieved by storing both keys in PEM files and then use `cat <file_name>` **in Backticks** to set the environment variables to the
output generated by by the `cat` command. Additionally you have to set `GSM_MODEM_USE_ECDSA` to any value. Key generation is explained in the documentation of
[`tokenissuer`](https://github.com/rmsk2/tokenissuer?tab=readme-ov-file#introduction).

# Installing `smssender` as a systemd service

The file `gsmmodem.service` contains a systemd unit file for `smssender` which assumes that the binary and `gsmmodem.env` are stored
in `/opt/gsmmodem`. Adapt the the unit and the env file to your needs and copy the service file to `/etc/systemd/system/gsmmodem.service`. After
that execute `systemctl daemon-reload`, `systemctl enable gsmmodem.service` and `systemctl start gsmmodem`. Following that you can check the services
log by using the command `journalctl -u gsmmodem -n`. ECDSA keys in the `.env` file have to be enclosed in `"` characters. No further quoting is needed. Here
an example:

```
GSM_MODEM_VERIFICATION_SECRET="-----BEGIN PUBLIC KEY-----
...
-----END PUBLIC KEY-----"
```

# Calling the REST service

As a default the service listens on port 4443. The listening port can be changed by setting the environment variable `GSM_MODEM_LISTENER_PORT` to
another valid value. You can send an SMS by a `POST` request to the path `/localsender/send` with a JSON body of the following form:

```
{
    "message": "This is a test message",
    "phone_nr" "4912345678901"
}
```

At least when using the Wavecom Q2303A the phone number has to start with the country code (i.e. here 49 for Germany). The JWT has to
be provided in a header with the key `X-Token`. Here an example using `curl`.

```
curl -X POST https://hostname:4443/localsender/send -H 'Content-Type: application/json; charset=utf-8' -H 'X-Token: xxxxxxxxxxxxxxxxxxxxxxxxxxx' --data-binary @test_body.json
```